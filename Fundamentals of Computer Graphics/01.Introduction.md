# 1.Introduction

### 1.0 Computer Graphics Definition
The term Computer Graphics describes any use of computers to create and manipulate images.

### 1.1 Graphics Areas

#### Major Areas  

* **Modeling**ï¼šModeling deals with the mathematical specification of shape and appearance properties in a way that can be stored on the computer.

* **Rendering**: Rendering is a term inherited from art and deals with the creation of shaded images from 3D computer models.

* **Animation**: Animation is a technique to create an illusion of motion through sequences of images. Animation uses modeling and rendering but adds the key issue of movement over time, which is not usually dealt with in basic modeling and rendering.

#### Related Areas
* User interaction  
* Virtual reality  
* Visualization  
* Image processing  
* Three-dimensional scanning  
* Computational Photography  

### 1.2 Major Applications

* Video games  
* Cartoons  
* Visual effects  
* Animated films  
* CAD/CAM  
* Simulation  
* Medical Imaging  
* Information Visualization  

### 1.3 Graphics APIs

An application program interface(API) is a standard collection of functions to perform a set of related operations, and a graphics API is a set of functions that perform basic operations such as drawing images and 3D surfaces into windows on the screen.

### 1.4 Graphics Pipeline

Graphics Pipeline: a special software/hardware subsystem that efficiently draws 3D primitives in perspective.

### 1.5 Numerical Issue

$$\infty$$
$$-\infty$$
Not a number(NaN)

### 1.6 Efficiency  

Programmers should pay more attention to memeory access patterns than to operation counts.

A resonable approach to making code fast is to proceed in the following order, taking only those steps which are needed:
1. write the code in the most straightforward way possible. Computer intermediate results as needed on the fly rather than storing them.
2. Compile in optimized mode.
3. Use whatever profiling tools exist to find critical bottlenecks
4. Examine data structures to look for ways to improve locality. If possible, make data unit sizes match the cache/page size on the target architecture.
5. If profiling reveals bottlenecks in numeric computations, examine the assembly code generated by the compiler for missed efficiencies. Rewrite source code to solve any problems you find.

### 1.7 Designing and Coding Graphics Programs

